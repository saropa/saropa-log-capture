/**
 * Bug report markdown formatter.
 *
 * Formats collected BugReportData into a structured markdown string
 * suitable for pasting into GitHub Issues, StackOverflow, or Slack.
 */

import type { BugReportData, StackFrame, FileAnalysis, CrossSessionMatch, FirebaseMatch } from './bug-report-collector';
import type { BlameLine } from './git-blame';
import type { SourceCodePreview, GitCommit } from './workspace-analyzer';
import type { DocScanResults } from './docs-scanner';
import type { ImportResults } from './import-extractor';
import type { SymbolResults } from './symbol-resolver';
import { type SectionData, scoreRelevance } from './analysis-relevance';
import { extractDateFromFilename } from './stack-parser';
import { buildVscodeFileUri, buildGitHubCommitUrl, buildMarkdownFileLink, type GitLinkContext } from './link-helpers';

interface ReportCtx {
    readonly remote?: string;
    readonly branch?: string;
}

/** Format collected data into a complete markdown bug report. */
export function formatBugReport(data: BugReportData): string {
    const ctx = extractReportCtx(data);
    const summary = formatExecutiveSummary(data);
    const sections = [
        formatHeader(),
        formatSources(data, ctx),
        ...(summary ? [summary] : []),
        formatError(data.errorLine, data.fingerprint),
        formatStackTrace(data.stackTrace, ctx),
        ...formatAffectedFiles(data.fileAnalyses, ctx),
        formatLogContext(data.logContext),
        formatEnvironment(data.environment),
        formatDevEnvSection(data.devEnvironment),
    ];
    if (data.sourcePreview) { sections.push(formatSourceCode(data.sourcePreview)); }
    if (data.blame) { sections.push(formatBlame(data.blame, ctx)); }
    if (data.gitHistory.length > 0) { sections.push(formatGitHistory(data.gitHistory, ctx)); }
    if (data.lineRangeHistory.length > 0) { sections.push(formatLineRangeHistory(data.lineRangeHistory, ctx)); }
    if (data.imports) { sections.push(formatImports(data.imports)); }
    if (data.docMatches?.matches.length) { sections.push(formatDocMatches(data.docMatches)); }
    if (data.resolvedSymbols?.symbols.length) { sections.push(formatSymbolDefs(data.resolvedSymbols)); }
    if (data.crossSessionMatch) { sections.push(formatCrossSession(data.crossSessionMatch)); }
    if (data.firebaseMatch) { sections.push(formatProductionImpact(data.firebaseMatch)); }
    sections.push(formatFooter(data.logFilename, data.lineNumber));
    return sections.join('\n\n');
}

function extractReportCtx(data: BugReportData): ReportCtx {
    return { remote: data.devEnvironment['Git Remote'], branch: data.devEnvironment['Git Branch'] };
}

function formatHeader(): string {
    const url = 'https://marketplace.visualstudio.com/items?itemName=Saropa.saropa-log-capture';
    return `# Bug Report\n\n**Generated by [Saropa Log Capture](${url})** | ${new Date().toISOString()}`;
}

function formatSources(data: BugReportData, ctx: ReportCtx): string {
    const items: string[] = [];
    items.push(`- **Log file:** \`${data.logFilename}\` line ${data.lineNumber}`);
    const sourceFiles = collectSourcePaths(data);
    if (sourceFiles.length > 0) { items.push(`- **Source files:** ${sourceFiles.map(f => `\`${f}\``).join(', ')}`); }
    const docFiles = data.docMatches?.matches.map(m => m.filename) ?? [];
    const uniqueDocs = [...new Set(docFiles)];
    if (uniqueDocs.length > 0) { items.push(`- **Documentation:** ${uniqueDocs.map(f => `\`${f}\``).join(', ')}`); }
    if (ctx.remote) { items.push(`- **Repository:** [${ctx.remote}](${ctx.remote})`); }
    return `## Sources\n\n${items.join('\n')}`;
}

function collectSourcePaths(data: BugReportData): string[] {
    const paths: string[] = [];
    if (data.primarySourcePath) { paths.push(shortName(data.primarySourcePath)); }
    for (const fa of data.fileAnalyses) {
        const name = shortName(fa.filePath);
        if (!paths.includes(name)) { paths.push(name); }
    }
    return paths;
}

function shortName(filePath: string): string { return filePath.split(/[\\/]/).pop() ?? filePath; }

function formatError(errorLine: string, fingerprint: string): string {
    return `## Error\n\n\`\`\`\n${errorLine}\n\`\`\`\n\n**Fingerprint:** \`${fingerprint}\``;
}

function formatStackTrace(frames: readonly StackFrame[], ctx: ReportCtx): string {
    if (frames.length === 0) { return '## Stack Trace\n\n*No stack trace detected.*'; }
    const appCount = frames.filter(f => f.isApp).length;
    const fwCount = frames.length - appCount;
    const lines = frames.map(f => f.isApp ? `>>> ${f.text}` : `    ${f.text}`);
    const parts = [
        '## Stack Trace',
        `\`\`\`\n${lines.join('\n')}\n\`\`\``,
        `${frames.length} frames (${appCount} app, ${fwCount} framework) — \`>>>\` marks app code`,
    ];
    const linked = formatLinkedFrames(frames, ctx);
    if (linked) { parts.push(linked); }
    return parts.join('\n\n');
}

function formatLinkedFrames(frames: readonly StackFrame[], ctx: ReportCtx): string | undefined {
    const appFrames = frames.filter(f => f.isApp && f.sourceRef);
    if (appFrames.length === 0) { return undefined; }
    const items = appFrames.map(f => {
        const ref = f.sourceRef!;
        const display = `${ref.filePath}:${ref.line}${ref.col ? ':' + ref.col : ''}`;
        const gitCtx = makeGitCtx(ctx, ref.filePath);
        return `- ${buildMarkdownFileLink(display, undefined, ref.line, ref.col, gitCtx)}`;
    });
    return `**Linked app frames:**\n${items.join('\n')}`;
}

function formatLogContext(context: readonly string[]): string {
    if (context.length === 0) { return '## Log Context\n\n*No preceding log lines.*'; }
    const block = context.map(l => l.trimEnd()).join('\n');
    return `## Log Context (${context.length} lines before error)\n\n\`\`\`\n${block}\n\`\`\``;
}

function formatEnvironment(env: Record<string, string>): string {
    const keys = Object.keys(env);
    if (keys.length === 0) { return '## Environment\n\n*No environment data available.*'; }
    const rows = keys.map(k => `| ${k} | ${env[k]} |`);
    return `## Environment\n\n| Field | Value |\n|-------|-------|\n${rows.join('\n')}`;
}

function formatDevEnvSection(env: Record<string, string>): string {
    const keys = Object.keys(env);
    if (keys.length === 0) { return '## Development Environment\n\n*No dev environment data available.*'; }
    const rows = keys.map(k => `| ${k} | ${env[k]} |`);
    return `## Development Environment\n\n| Field | Value |\n|-------|-------|\n${rows.join('\n')}`;
}

function formatSourceCode(preview: SourceCodePreview): string {
    const lines = preview.lines.map(l => {
        const marker = l.num === preview.targetLine ? '-->' : '   ';
        return `${marker} ${String(l.num).padStart(4)} | ${l.text}`;
    });
    return `## Source Code\n\n\`\`\`\n${lines.join('\n')}\n\`\`\``;
}

function formatBlame(blame: BlameLine, ctx: ReportCtx): string {
    const hash = formatCommitHash(blame.hash, ctx);
    return `## Git Blame\n\nLast changed by **${blame.author}** on ${blame.date} · ${hash} ${blame.message}`;
}

function formatGitHistory(commits: readonly GitCommit[], ctx: ReportCtx): string {
    return formatCommitTable('## Recent Git History', commits, ctx);
}

function formatCrossSession(match: CrossSessionMatch): string {
    const sessions = match.sessionCount === 1 ? '1 session' : `${match.sessionCount} sessions`;
    const total = match.totalOccurrences === 1 ? '1 occurrence' : `${match.totalOccurrences} occurrences`;
    return [
        '## Cross-Session History',
        `This error has been seen in **${sessions}** with **${total}**.`,
        `- First seen: ${match.firstSeen}`,
        `- Last seen: ${match.lastSeen}`,
    ].join('\n');
}

function formatProductionImpact(fb: FirebaseMatch): string {
    const lines = [
        '## Production Impact (Firebase Crashlytics)',
        `- **Issue:** ${fb.issueTitle}`,
        `- **Events:** ${fb.eventCount}`,
        `- **Users affected:** ${fb.userCount}`,
    ];
    if (fb.firstVersion && fb.lastVersion && fb.firstVersion !== fb.lastVersion) {
        lines.push(`- **Versions:** ${fb.firstVersion} → ${fb.lastVersion}`);
    } else if (fb.firstVersion) {
        lines.push(`- **Version:** ${fb.firstVersion}`);
    }
    if (fb.consoleUrl) { lines.push(`- **Console:** [View in Firebase](${fb.consoleUrl})`); }
    return lines.join('\n');
}

function formatLineRangeHistory(commits: readonly GitCommit[], ctx: ReportCtx): string {
    return formatCommitTable('## Recent Changes Near Error', commits, ctx);
}

function formatAffectedFiles(analyses: readonly FileAnalysis[], ctx: ReportCtx): string[] {
    if (analyses.length === 0) { return []; }
    const parts = analyses.map(fa => formatOneFileAnalysis(fa, ctx));
    return [`## Affected Files (${analyses.length})\n\n${parts.join('\n\n---\n\n')}`];
}

function formatOneFileAnalysis(fa: FileAnalysis, ctx: ReportCtx): string {
    const name = shortName(fa.filePath);
    const gitCtx = makeGitCtx(ctx, fa.filePath);
    const heading = buildMarkdownFileLink(name, fa.uri.fsPath, fa.frameLines[0], undefined, gitCtx);
    const lines = fa.frameLines.map(l => `L${l}`).join(', ');
    let md = `### ${heading}\n\n**Stack trace lines:** ${lines}`;
    if (fa.blame) {
        const hash = formatCommitHash(fa.blame.hash, ctx);
        md += `\n\n**Last changed:** ${fa.blame.author} on ${fa.blame.date} · ${hash} ${fa.blame.message}`;
    }
    if (fa.recentCommits.length > 0) {
        const rows = fa.recentCommits.map(c => `| ${formatCommitHash(c.hash, ctx)} | ${c.date} | ${escapePipe(c.message)} |`);
        md += `\n\n| Hash | Date | Message |\n|------|------|---------|\n${rows.join('\n')}`;
    }
    return md;
}

function formatCommitTable(heading: string, commits: readonly GitCommit[], ctx: ReportCtx): string {
    const rows = commits.map(c => `| ${formatCommitHash(c.hash, ctx)} | ${c.date} | ${escapePipe(c.message)} |`);
    return [heading, '| Hash | Date | Message |\n|------|------|---------|\n' + rows.join('\n')].join('\n\n');
}

function formatImports(results: ImportResults): string {
    if (results.imports.length === 0) { return '## Dependencies\n\n*No imports detected.*'; }
    const local = results.imports.filter(i => i.isLocal).map(i => `- \`${i.module}\` (L${i.line})`);
    const pkg = results.imports.filter(i => !i.isLocal).map(i => `- \`${i.module}\` (L${i.line})`);
    let md = `## Dependencies (${results.language})\n\n`;
    if (local.length > 0) { md += `**Local** (${local.length}):\n${local.join('\n')}\n\n`; }
    if (pkg.length > 0) { md += `**Packages** (${pkg.length}):\n${pkg.join('\n')}`; }
    return md.trimEnd();
}

function formatDocMatches(results: DocScanResults): string {
    const rows = results.matches.map(m => {
        const loc = `[${m.filename}:${m.lineNumber}](${buildVscodeFileUri(m.uri.fsPath, m.lineNumber)})`;
        return `| ${loc} | ${escapePipe(m.matchedToken)} | ${escapePipe(m.lineText.trim().slice(0, 80))} |`;
    });
    return [
        `## Related Documentation (${results.matches.length} references)`,
        '| Location | Token | Context |\n|----------|-------|---------|\n' + rows.join('\n'),
    ].join('\n\n');
}

function formatSymbolDefs(results: SymbolResults): string {
    const rows = results.symbols.map(s => {
        const file = shortName(s.uri.fsPath);
        const loc = `[${file}:${s.line}](${buildVscodeFileUri(s.uri.fsPath, s.line)})`;
        return `| ${s.kind} | ${escapePipe(s.name)} | ${loc} | ${escapePipe(s.containerName)} |`;
    });
    return [
        '## Symbol Definitions',
        '| Kind | Name | Location | Container |\n|------|------|----------|-----------|\n' + rows.join('\n'),
    ].join('\n\n');
}

function formatExecutiveSummary(data: BugReportData): string | undefined {
    const sectionData = extractSectionData(data);
    const { findings } = scoreRelevance(sectionData);
    const bullets = findings.filter(f => f.text && (f.level === 'high' || f.level === 'medium'));
    if (bullets.length === 0) { return undefined; }
    const lines = bullets.map(f => `- ${f.icon} ${f.text}`);
    return `## Key Findings\n\n${lines.join('\n')}`;
}

function extractSectionData(data: BugReportData): SectionData {
    return {
        blame: data.blame ? { date: data.blame.date, author: data.blame.author, hash: data.blame.hash } : undefined,
        lineCommits: data.lineRangeHistory.map(c => ({ date: c.date })),
        annotations: [],
        crossSession: data.crossSessionMatch ? { sessionCount: data.crossSessionMatch.sessionCount, totalOccurrences: data.crossSessionMatch.totalOccurrences, firstSeenDate: extractDateFromFilename(data.crossSessionMatch.firstSeen) } : undefined,
        docMatchCount: data.docMatches?.matches.length ?? 0,
        symbolCount: data.resolvedSymbols?.symbols.length ?? 0,
        tokenMatchCount: 0,
        tokenFileCount: 0,
        importCount: data.imports?.imports.length ?? 0,
        localImportCount: data.imports?.localCount ?? 0,
        gitCommitCount: data.gitHistory.length,
        affectedFileCount: data.fileAnalyses.length,
    };
}

function escapePipe(text: string): string { return text.replace(/\|/g, '\\|'); }

function formatFooter(filename: string, lineNumber: number): string {
    return [
        '---',
        `*Report generated from \`${filename}\` at line ${lineNumber}*`,
        `**[Saropa Lints](https://pub.dev/packages/saropa_lints/changelog)** — Catch memory leaks, security vulnerabilities, and runtime crashes that standard linters miss. Developed by [Saropa](https://saropa.com/about) to make the world of Dart & Flutter better.`,
    ].join('\n\n');
}

function makeGitCtx(ctx: ReportCtx, filePath: string): GitLinkContext | undefined {
    if (!ctx.remote || !ctx.branch) { return undefined; }
    return { remoteUrl: ctx.remote, branch: ctx.branch, relativePath: filePath };
}

function formatCommitHash(hash: string, ctx: ReportCtx): string {
    if (!ctx.remote) { return `\`${hash}\``; }
    const url = buildGitHubCommitUrl(ctx.remote, hash);
    return url ? `[\`${hash}\`](${url})` : `\`${hash}\``;
}
