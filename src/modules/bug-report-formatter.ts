/**
 * Bug report markdown formatter.
 *
 * Formats collected BugReportData into a structured markdown string
 * suitable for pasting into GitHub Issues, StackOverflow, or Slack.
 */

import type { BugReportData, StackFrame, CrossSessionMatch } from './bug-report-collector';
import type { SourceCodePreview, GitCommit } from './workspace-analyzer';

/** Format collected data into a complete markdown bug report. */
export function formatBugReport(data: BugReportData): string {
    const sections = [
        formatHeader(),
        formatError(data.errorLine, data.fingerprint),
        formatStackTrace(data.stackTrace),
        formatLogContext(data.logContext),
        formatEnvironment(data.environment),
    ];
    if (data.sourcePreview) { sections.push(formatSourceCode(data.sourcePreview)); }
    if (data.gitHistory.length > 0) { sections.push(formatGitHistory(data.gitHistory)); }
    if (data.crossSessionMatch) { sections.push(formatCrossSession(data.crossSessionMatch)); }
    sections.push(formatFooter(data.logFilename, data.lineNumber));
    return sections.join('\n\n');
}

function formatHeader(): string {
    return `# Bug Report\n\n**Generated by Saropa Log Capture** | ${new Date().toISOString()}`;
}

function formatError(errorLine: string, fingerprint: string): string {
    return `## Error\n\n\`\`\`\n${errorLine}\n\`\`\`\n\n**Fingerprint:** \`${fingerprint}\``;
}

function formatStackTrace(frames: readonly StackFrame[]): string {
    if (frames.length === 0) { return '## Stack Trace\n\n*No stack trace detected.*'; }
    const appCount = frames.filter(f => f.isApp).length;
    const fwCount = frames.length - appCount;
    const lines = frames.map(f => f.isApp ? `>>> ${f.text}` : `    ${f.text}`);
    return [
        '## Stack Trace',
        `\`\`\`\n${lines.join('\n')}\n\`\`\``,
        `${frames.length} frames (${appCount} app, ${fwCount} framework) â€” \`>>>\` marks app code`,
    ].join('\n\n');
}

function formatLogContext(context: readonly string[]): string {
    if (context.length === 0) { return '## Log Context\n\n*No preceding log lines.*'; }
    const block = context.map(l => l.trimEnd()).join('\n');
    return `## Log Context (${context.length} lines before error)\n\n\`\`\`\n${block}\n\`\`\``;
}

function formatEnvironment(env: Record<string, string>): string {
    const keys = Object.keys(env);
    if (keys.length === 0) { return '## Environment\n\n*No environment data available.*'; }
    const rows = keys.map(k => `| ${k} | ${env[k]} |`);
    return `## Environment\n\n| Field | Value |\n|-------|-------|\n${rows.join('\n')}`;
}

function formatSourceCode(preview: SourceCodePreview): string {
    const lines = preview.lines.map(l => {
        const marker = l.num === preview.targetLine ? '-->' : '   ';
        return `${marker} ${String(l.num).padStart(4)} | ${l.text}`;
    });
    return `## Source Code\n\n\`\`\`\n${lines.join('\n')}\n\`\`\``;
}

function formatGitHistory(commits: readonly GitCommit[]): string {
    const rows = commits.map(c => `| \`${c.hash}\` | ${c.date} | ${c.message} |`);
    return [
        '## Recent Git History',
        '| Hash | Date | Message |\n|------|------|---------|\n' + rows.join('\n'),
    ].join('\n\n');
}

function formatCrossSession(match: CrossSessionMatch): string {
    const sessions = match.sessionCount === 1 ? '1 session' : `${match.sessionCount} sessions`;
    const total = match.totalOccurrences === 1 ? '1 occurrence' : `${match.totalOccurrences} occurrences`;
    return [
        '## Cross-Session History',
        `This error has been seen in **${sessions}** with **${total}**.`,
        `- First seen: ${match.firstSeen}`,
        `- Last seen: ${match.lastSeen}`,
    ].join('\n');
}

function formatFooter(filename: string, lineNumber: number): string {
    return `---\n*Report generated from \`${filename}\` at line ${lineNumber}*`;
}
